# Vue 3 依赖收集三重检查逻辑深度分析

## 1. 代码位置与作用

这段代码位于 `packages/reactivity/src/dep.ts` 的 `Dep.track()` 方法中，是Vue 3响应式系统进行依赖收集的**核心入口检查**。

```typescript
// packages/reactivity/src/dep.ts:153-181
if (
  !activeSub || // 检查1: 当前是否有活跃的订阅者（effect或computed）
  !shouldTrack || // 检查2: 全局依赖跟踪开关是否开启
  activeSub === this.computed // 检查3: 避免computed对自身的循环依赖
) {
  return // 三重安全检查，任何一个条件不满足都不进行依赖收集
}
```

## 2. 三重检查详细分析

### 2.1 第一重检查：`!activeSub`

#### 检查目的

确认当前是否有活跃的订阅者（Subscriber）在执行

#### 技术细节

```typescript
export let activeSub: Subscriber | undefined
```

- **activeSub** 是全局变量，指向当前正在执行的订阅者
- **Subscriber** 包括：`ReactiveEffect`（effect函数）和 `ComputedRefImpl`（computed属性）
- 当没有effect或computed在执行时，`activeSub` 为 `undefined`

#### 触发场景分析

**✅ 正常情况（activeSub存在）**：

```typescript
// 场景1: effect函数执行中
effect(() => {
  console.log(obj.count) // 此时 activeSub = ReactiveEffect实例
})

// 场景2: computed求值中
const doubled = computed(() => {
  return obj.count * 2 // 此时 activeSub = ComputedRefImpl实例
})
console.log(doubled.value)

// 场景3: 组件渲染中
// 组件render函数执行时，activeSub = 组件的渲染effect
```

**❌ 跳过情况（!activeSub为true）**：

```typescript
// 场景1: 普通属性访问
const obj = reactive({ count: 0 })
console.log(obj.count) // 没有在effect中，不收集依赖

// 场景2: 在effect外部访问
let value
effect(() => {
  value = obj.count // 这里会收集依赖
})
console.log(obj.count) // 这里不会收集依赖，因为不在effect中

// 场景3: 初始化阶段
const obj = reactive({ count: 0 }) // 创建时不收集依赖
```

#### 设计优势

- **性能优化**：避免无效的依赖收集开销
- **内存节省**：减少不必要的依赖关系对象创建
- **逻辑清晰**：明确区分响应式上下文和普通访问

### 2.2 第二重检查：`!shouldTrack`

#### 检查目的

全局控制依赖跟踪的开启/关闭状态

#### 技术细节

```typescript
export let shouldTrack = true
const trackStack: boolean[] = []

// 暂停跟踪
export function pauseTracking(): void {
  trackStack.push(shouldTrack)
  shouldTrack = false
}

// 恢复跟踪
export function enableTracking(): void {
  trackStack.push(shouldTrack)
  shouldTrack = true
}

// 重置跟踪状态
export function resetTracking(): void {
  const last = trackStack.pop()
  shouldTrack = last === undefined ? true : last
}
```

#### 使用场景分析

**🔒 暂停跟踪的场景**：

```typescript
// 场景1: 初始化过程中访问响应式数据
function setupComponent() {
  pauseTracking() // 暂停依赖收集
  // 访问props、默认值等，不希望建立依赖关系
  const defaultValue = props.value || reactive.defaultValue
  resetTracking() // 恢复依赖收集状态
}

// 场景2: 某些工具函数中
function debugReactiveObject(obj) {
  pauseTracking()
  // 遍历对象属性用于调试，不应该建立依赖
  Object.keys(obj).forEach(key => console.log(key, obj[key]))
  resetTracking()
}

// 场景3: 性能敏感的代码路径
function batchUpdate() {
  pauseTracking()
  // 批量更新多个响应式属性，避免中间状态的依赖收集
  obj.a = 1
  obj.b = 2
  obj.c = 3
  resetTracking()
}
```

#### 栈式管理的优势

```typescript
// 支持嵌套的跟踪控制
effect(() => {
  console.log(obj.a) // 收集依赖

  pauseTracking()
  console.log(obj.b) // 不收集依赖

  effect(() => {
    enableTracking()
    console.log(obj.c) // 收集依赖
  })

  resetTracking() // 恢复到pauseTracking前的状态
})
```

### 2.3 第三重检查：`activeSub === this.computed`

#### 检查目的

防止computed属性对自身建立循环依赖关系

#### 问题场景

```typescript
// 有问题的computed定义（会导致循环依赖）
const problematicComputed = computed(() => {
  // 在computed内部访问自己，会导致无限循环
  return problematicComputed.value + 1 // ❌ 危险！
})
```

#### 技术实现分析

```typescript
// ComputedRefImpl的get value()方法
get value(): T {
  // 当访问computed.value时，会调用dep.track()
  const link = this.dep.track() // 这里会检查 activeSub === this.computed
  refreshComputed(this)
  return this._value
}

// refreshComputed函数中
function refreshComputed(computed: ComputedRefImpl): void {
  // 设置activeSub为当前computed
  activeSub = computed
  try {
    // 执行computed的计算函数
    const value = computed.fn(computed._value)
  } finally {
    activeSub = prevSub
  }
}
```

#### 循环依赖的检测机制

```typescript
// 正常情况：computed访问其他响应式数据
const count = ref(0)
const doubled = computed(() => {
  // activeSub = ComputedRefImpl(doubled)
  // 访问count.value时，count.dep !== doubled.dep，正常收集依赖
  return count.value * 2 // ✅ 正常
})

// 异常情况：computed访问自身
const selfRef = computed(() => {
  // activeSub = ComputedRefImpl(selfRef)
  // 访问selfRef.value时，selfRef.dep === this.computed，跳过依赖收集
  return selfRef.value + 1 // ❌ 被阻止，避免循环
})
```

#### 防护效果

- **避免栈溢出**：防止无限递归调用
- **性能保护**：避免无意义的循环计算
- **逻辑正确性**：确保computed的语义正确

## 3. 三重检查的协同工作

### 3.1 检查优先级

```typescript
// 检查顺序是经过精心设计的
if (
  !activeSub || // 优先级1: 最基础的存在性检查
  !shouldTrack || // 优先级2: 全局开关检查
  activeSub === this.computed // 优先级3: 特定场景的安全检查
) {
  return
}
```

### 3.2 性能优化考虑

- **短路求值**：使用 `||` 操作符，任何一个条件为true就立即返回
- **最常见情况优先**：将最可能为true的条件放在前面
- **开销递增排序**：简单的存在性检查 → 全局变量检查 → 对象比较

### 3.3 不同场景下的行为

#### 场景1: 普通属性访问

```typescript
const obj = reactive({ count: 0 })
console.log(obj.count)
// !activeSub = true → 直接返回，不收集依赖
```

#### 场景2: effect中的属性访问

```typescript
effect(() => {
  console.log(obj.count)
  // activeSub = ReactiveEffect实例
  // shouldTrack = true
  // activeSub !== computed
  // → 通过所有检查，收集依赖
})
```

#### 场景3: 暂停跟踪状态下的访问

```typescript
effect(() => {
  pauseTracking()
  console.log(obj.count)
  // activeSub = ReactiveEffect实例
  // !shouldTrack = true → 跳过依赖收集
  resetTracking()
})
```

#### 场景4: computed自引用

```typescript
const selfComputed = computed(() => {
  return selfComputed.value + 1
  // activeSub = ComputedRefImpl实例
  // shouldTrack = true
  // activeSub === this.computed = true → 阻止循环依赖
})
```

## 4. 错误处理与边界情况

### 4.1 开发环境下的额外检查

```typescript
if (__DEV__ && activeSub && !shouldTrack) {
  console.warn('依赖跟踪被暂停，但仍有活跃的订阅者')
}
```

### 4.2 嵌套effect的处理

```typescript
effect(() => {
  // activeSub = effect1
  console.log(obj.a) // 收集到effect1

  effect(() => {
    // activeSub = effect2 (effect1被保存)
    console.log(obj.b) // 收集到effect2
  })

  // activeSub = effect1 (恢复)
  console.log(obj.c) // 收集到effect1
})
```

### 4.3 computed嵌套的处理

```typescript
const inner = computed(() => obj.count * 2)
const outer = computed(() => {
  // activeSub = outer的ComputedRefImpl
  return inner.value + 1 // inner.dep !== outer.dep，正常收集依赖
})
```

## 5. 最佳实践与建议

### 5.1 正确使用pauseTracking

```typescript
// ✅ 正确用法
function utilityFunction() {
  pauseTracking()
  try {
    // 执行不应该收集依赖的操作
    return processReactiveData()
  } finally {
    resetTracking() // 确保恢复状态
  }
}

// ❌ 错误用法
function badFunction() {
  pauseTracking()
  // 忘记调用resetTracking()，会影响后续的依赖收集
  return processReactiveData()
}
```

### 5.2 避免computed循环依赖

```typescript
// ✅ 正确的computed设计
const count = ref(0)
const doubled = computed(() => count.value * 2)
const quadrupled = computed(() => doubled.value * 2)

// ❌ 避免的computed模式
const bad = computed(() => {
  return bad.value + 1 // 自引用
})

const a = computed(() => b.value + 1)
const b = computed(() => a.value + 1) // 相互引用
```

### 5.3 理解依赖收集的时机

```typescript
// 依赖收集只在特定时机发生
const obj = reactive({ count: 0 })

// 不会收集依赖的情况
obj.count = 1 // 赋值操作
delete obj.count // 删除操作
Object.defineProperty(obj, 'newProp', {}) // 属性定义

// 会收集依赖的情况（在effect或computed中）
effect(() => {
  console.log(obj.count) // 读取操作
  console.log('count' in obj) // in操作符
  console.log(Object.keys(obj)) // 枚举操作
})
```

## 6. 总结

这三重检查逻辑是Vue 3响应式系统的**智能防护机制**：

1. **`!activeSub`** - 确保只在响应式上下文中收集依赖
2. **`!shouldTrack`** - 提供灵活的全局控制能力
3. **`activeSub === this.computed`** - 防止computed的循环依赖

通过这种设计，Vue 3实现了：

- **高性能**：避免无效的依赖收集
- **高安全性**：防止循环依赖和内存泄漏
- **高灵活性**：支持复杂的嵌套和控制场景
- **高可靠性**：确保响应式系统的稳定运行

这是现代前端框架中响应式系统设计的典型代表，体现了对性能、安全性和可维护性的全面考虑。
