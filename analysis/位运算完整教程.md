# JavaScript 位运算完整教程

## 目录

1. [位运算基础概念](#位运算基础概念)
2. [二进制数系统](#二进制数系统)
3. [JavaScript 中的位运算符](#javascript-中的位运算符)
4. [位运算实际应用](#位运算实际应用)
5. [Vue 3 中的位运算应用](#vue-3-中的位运算应用)
6. [常见问题和陷阱](#常见问题和陷阱)
7. [实践练习](#实践练习)

---

## 位运算基础概念

### 什么是位运算？

位运算是直接对整数在内存中的二进制位进行操作的运算。它是计算机最基础的运算方式，速度非常快。

### 为什么要学习位运算？

1. **性能优势**：位运算是 CPU 最基础的操作，执行速度极快
2. **内存效率**：可以用一个整数存储多个布尔值
3. **算法应用**：许多高效算法都基于位运算
4. **框架源码**：Vue、React 等框架大量使用位运算

---

## 二进制数系统

### 什么是二进制？

二进制是一种**基数为2的记数系统**，只使用0和1两个数字。这是计算机内部表示和处理数据的基础方式。

**为什么计算机使用二进制？**

1. **电子器件特性**：开关只有开/关两种状态，对应1/0
2. **简化电路设计**：只需要区分高电平和低电平
3. **抗干扰能力强**：两种状态差异明显，不易出错
4. **逻辑运算简单**：布尔代数直接对应二进制运算

### 数制转换原理

#### 1. 十进制到二进制的转换

**方法一：除2取余法**

```
将13转换为二进制：
13 ÷ 2 = 6 ... 余数 1  ↑
6  ÷ 2 = 3 ... 余数 0  |
3  ÷ 2 = 1 ... 余数 1  |
1  ÷ 2 = 0 ... 余数 1  |

从下往上读取余数：1101
所以 13(十进制) = 1101(二进制)
```

**方法二：权值分解法**

```
13 = 8 + 4 + 1 = 2³ + 2² + 2⁰
   = 1×2³ + 1×2² + 0×2¹ + 1×2⁰
   = 1101(二进制)

权值表：
位置： 7  6  5  4  3  2  1  0
权值：128 64 32 16  8  4  2  1
```

**JavaScript实现：**

```javascript
// 十进制转二进制
function decimalToBinary(decimal) {
  if (decimal === 0) return '0'

  let binary = ''
  while (decimal > 0) {
    binary = (decimal % 2) + binary
    decimal = Math.floor(decimal / 2)
  }
  return binary
}

console.log(decimalToBinary(13)) // "1101"
console.log((13).toString(2)) // "1101" (内置方法)
```

#### 2. 二进制到十进制的转换

**按权值相加法：**

```
二进制 1101 转换为十进制：

位置：  3  2  1  0
数值：  1  1  0  1
权值：  8  4  2  1

计算：1×8 + 1×4 + 0×2 + 1×1 = 8 + 4 + 0 + 1 = 13
```

**JavaScript实现：**

```javascript
// 二进制转十进制
function binaryToDecimal(binary) {
  let decimal = 0
  let power = 0

  // 从右到左处理每一位
  for (let i = binary.length - 1; i >= 0; i--) {
    if (binary[i] === '1') {
      decimal += Math.pow(2, power)
    }
    power++
  }
  return decimal
}

console.log(binaryToDecimal('1101')) // 13
console.log(parseInt('1101', 2)) // 13 (内置方法)
```

### 二进制基础对照表

```
十进制 | 二进制(4位) | 二进制(8位)  | 十六进制 | 说明
-------|------------|-------------|---------|------------------
0      | 0000       | 00000000    | 0x0     | 最小值
1      | 0001       | 00000001    | 0x1     | 最低位为1
2      | 0010       | 00000010    | 0x2     | 第1位为1
3      | 0011       | 00000011    | 0x3     | 第0,1位为1
4      | 0100       | 00000100    | 0x4     | 第2位为1
5      | 0101       | 00000101    | 0x5     | 第0,2位为1
6      | 0110       | 00000110    | 0x6     | 第1,2位为1
7      | 0111       | 00000111    | 0x7     | 第0,1,2位为1
8      | 1000       | 00001000    | 0x8     | 第3位为1
15     | 1111       | 00001111    | 0xF     | 低4位全为1
16     | 10000      | 00010000    | 0x10    | 第4位为1
255    | 11111111   | 11111111    | 0xFF    | 8位全为1
```

### 位的概念详解

#### 位的编号和位置

```
二进制数：  1  0  1  1
位位置：    3  2  1  0  (从右到左，从0开始编号)
权值：      8  4  2  1  (2的幂次方)
位名称：   MSB      LSB

MSB = Most Significant Bit (最高有效位)
LSB = Least Significant Bit (最低有效位)
```

#### 位的重要性

```javascript
// 每一位代表不同的权值
const number = 13 // 二进制: 1101

// 检查各位的值
console.log('第0位 (权值1):', !!(number & (1 << 0))) // true
console.log('第1位 (权值2):', !!(number & (1 << 1))) // false
console.log('第2位 (权值4):', !!(number & (1 << 2))) // true
console.log('第3位 (权值8):', !!(number & (1 << 3))) // true

// 计算权值总和
let sum = 0
for (let i = 0; i < 4; i++) {
  if (number & (1 << i)) {
    sum += 1 << i
    console.log(`第${i}位为1，权值为${1 << i}`)
  }
}
console.log('总和:', sum) // 13
```

### 不同进制的表示方法

#### JavaScript中的进制表示

```javascript
// 各种进制的表示方法
const decimal = 15
const binary = 0b1111 // 二进制前缀 0b
const octal = 0o17 // 八进制前缀 0o
const hex = 0xf // 十六进制前缀 0x

console.log(decimal, binary, octal, hex) // 15 15 15 15

// 进制转换方法
const num = 255
console.log('十进制:', num)
console.log('二进制:', num.toString(2)) // "11111111"
console.log('八进制:', num.toString(8)) // "377"
console.log('十六进制:', num.toString(16)) // "ff"

// 解析不同进制的字符串
console.log(parseInt('11111111', 2)) // 255
console.log(parseInt('377', 8)) // 255
console.log(parseInt('ff', 16)) // 255
```

### 二进制的算术运算

#### 二进制加法

```
基本规则：
0 + 0 = 0
0 + 1 = 1
1 + 0 = 1
1 + 1 = 10 (进位)

示例：1011 + 1101
  1011
+ 1101
------
 11000

逐位计算：
第0位: 1+1=10 (写0进1)
第1位: 1+0+1(进位)=10 (写0进1)
第2位: 0+1+1(进位)=10 (写0进1)
第3位: 1+1+1(进位)=11 (写1进1)
第4位: 0+0+1(进位)=1
```

#### 二进制减法

```
基本规则：
0 - 0 = 0
1 - 0 = 1
1 - 1 = 0
0 - 1 = 1 (借位)

示例：1101 - 1011
  1101
- 1011
------
  0010
```

### 补码系统 (重要概念)

#### 为什么需要补码？

计算机需要表示负数，补码是最有效的方式：

```javascript
// JavaScript中的32位有符号整数
console.log((5).toString(2)) // "101"
console.log((-5).toString(2)) // "-101" (显示形式)

// 实际存储的补码形式 (32位)
const positive5 = 5
const negative5 = -5

// 查看实际的二进制表示
console.log((positive5 >>> 0).toString(2).padStart(32, '0'))
// "00000000000000000000000000000101"

console.log((negative5 >>> 0).toString(2).padStart(32, '0'))
// "11111111111111111111111111111011"
```

#### 补码的计算方法

```
求-5的补码 (8位示例)：

1. 写出5的二进制:     00000101
2. 按位取反(反码):    11111010
3. 加1得到补码:       11111011

验证：11111011 + 00000101 = 100000000 (溢出，结果为0) ✓
```

**JavaScript实现：**

```javascript
function getTwosComplement(num, bits = 8) {
  // 获取正数的二进制
  const positive = Math.abs(num)
  let binary = positive.toString(2).padStart(bits, '0')

  if (num >= 0) return binary

  // 计算补码
  // 1. 按位取反
  let inverted = ''
  for (let i = 0; i < binary.length; i++) {
    inverted += binary[i] === '0' ? '1' : '0'
  }

  // 2. 加1
  let carry = 1
  let result = ''
  for (let i = inverted.length - 1; i >= 0; i--) {
    const sum = parseInt(inverted[i]) + carry
    result = (sum % 2) + result
    carry = Math.floor(sum / 2)
  }

  return result
}

console.log(getTwosComplement(5, 8)) // "00000101"
console.log(getTwosComplement(-5, 8)) // "11111011"
```

### 二进制在实际编程中的应用

#### 1. 颜色表示

```javascript
// RGB颜色的二进制表示
const red = 0xff0000 // 11111111 00000000 00000000
const green = 0x00ff00 // 00000000 11111111 00000000
const blue = 0x0000ff // 00000000 00000000 11111111

// 提取RGB分量
function getRGB(color) {
  return {
    red: (color >> 16) & 0xff, // 右移16位，取低8位
    green: (color >> 8) & 0xff, // 右移8位，取低8位
    blue: color & 0xff, // 直接取低8位
  }
}

const purple = 0x800080
console.log(getRGB(purple)) // {red: 128, green: 0, blue: 128}
```

#### 2. 文件权限 (Unix/Linux)

```javascript
// Unix文件权限的二进制表示
const permissions = {
  OWNER_READ: 0b100000000, // 256
  OWNER_WRITE: 0b010000000, // 128
  OWNER_EXECUTE: 0b001000000, // 64
  GROUP_READ: 0b000100000, // 32
  GROUP_WRITE: 0b000010000, // 16
  GROUP_EXECUTE: 0b000001000, // 8
  OTHER_READ: 0b000000100, // 4
  OTHER_WRITE: 0b000000010, // 2
  OTHER_EXECUTE: 0b000000001, // 1
}

// chmod 755 的二进制表示
const chmod755 =
  permissions.OWNER_READ |
  permissions.OWNER_WRITE |
  permissions.OWNER_EXECUTE |
  permissions.GROUP_READ |
  permissions.GROUP_EXECUTE |
  permissions.OTHER_READ |
  permissions.OTHER_EXECUTE

console.log(chmod755.toString(8)) // "755"
console.log(chmod755.toString(2)) // "111101101"
```

### JavaScript 中的数字表示

```javascript
// JavaScript 中数字的二进制表示
console.log((5).toString(2)) // "101"
console.log((8).toString(2)) // "1000"
console.log((255).toString(2)) // "11111111"

// 解析二进制字符串为数字
console.log(parseInt('101', 2)) // 5
console.log(parseInt('1000', 2)) // 8
```

---

## JavaScript 中的位运算符

### 1. 按位与 (AND) - `&`

**语法**：`a & b`
**规则**：两个对应位都是 1 时，结果为 1，否则为 0

```javascript
// 示例
5 & 3
// 5: 101
// 3: 011
// &: 001 = 1

console.log(5 & 3) // 1

// 实际应用：检查某一位是否为 1
const flags = 5 // 101
const mask = 1 // 001 (检查第0位)
console.log(flags & mask) // 1 (第0位是1)

const mask2 = 2 // 010 (检查第1位)
console.log(flags & mask2) // 0 (第1位是0)
```

### 2. 按位或 (OR) - `|`

**语法**：`a | b`
**规则**：两个对应位有一个是 1 时，结果为 1

```javascript
// 示例
5 | 3
// 5: 101
// 3: 011
// |: 111 = 7

console.log(5 | 3) // 7

// 实际应用：设置某一位为 1
let flags = 4 // 100
flags = flags | 1 // 100 | 001 = 101
console.log(flags) // 5

// 简写形式
flags |= 2 // flags = flags | 2
console.log(flags) // 7 (111)
```

### 3. 按位异或 (XOR) - `^`

**语法**：`a ^ b`
**规则**：两个对应位不同时，结果为 1

```javascript
// 示例
5 ^ 3
// 5: 101
// 3: 011
// ^: 110 = 6

console.log(5 ^ 3) // 6

// 实际应用：切换某一位
let flags = 5 // 101
flags ^= 1 // 切换第0位: 101 ^ 001 = 100
console.log(flags) // 4

flags ^= 1 // 再次切换第0位: 100 ^ 001 = 101
console.log(flags) // 5 (回到原值)
```

### 4. 按位非 (NOT) - `~`

**语法**：`~a`
**规则**：将所有位取反

```javascript
// 示例 (注意：JavaScript 使用 32 位有符号整数)
console.log(~5) // -6

// 二进制表示：
// 5:  00000000000000000000000000000101
// ~5: 11111111111111111111111111111010 (补码表示为 -6)

// 实际应用：清除某一位
let flags = 7 // 111
const mask = 2 // 010
flags = flags & ~mask // 111 & 101 = 101
console.log(flags) // 5
```

### 5. 左移 (Left Shift) - `<<`

**语法**：`a << b`
**规则**：将 a 的二进制位向左移动 b 位，右边补 0

```javascript
// 示例
console.log(5 << 1) // 10
// 5:  101
// <<1: 1010 = 10

console.log(5 << 2) // 20
// 5:  101
// <<2: 10100 = 20

// 数学规律：a << b = a * (2^b)
console.log(1 << 0) // 1  = 1 * 2^0
console.log(1 << 1) // 2  = 1 * 2^1
console.log(1 << 2) // 4  = 1 * 2^2
console.log(1 << 3) // 8  = 1 * 2^3
```

### 6. 右移 (Right Shift) - `>>`

**语法**：`a >> b`
**规则**：将 a 的二进制位向右移动 b 位，左边补符号位

```javascript
// 示例
console.log(20 >> 1) // 10
// 20: 10100
// >>1: 1010 = 10

console.log(20 >> 2) // 5
// 20: 10100
// >>2: 101 = 5

// 数学规律：a >> b = Math.floor(a / (2^b))
console.log(8 >> 1) // 4 = 8 / 2
console.log(8 >> 2) // 2 = 8 / 4
console.log(8 >> 3) // 1 = 8 / 8
```

### 7. 无符号右移 (Unsigned Right Shift) - `>>>`

**语法**：`a >>> b`
**规则**：将 a 的二进制位向右移动 b 位，左边总是补 0

```javascript
// 示例
console.log(-1 >> 1) // -1 (符号位扩展)
console.log(-1 >>> 1) // 2147483647 (左边补0)

// 主要用于处理无符号数
console.log(20 >>> 1) // 10 (与 >> 相同，对正数)
```

---

## 位运算实际应用

### 1. 权限系统

```javascript
// 定义权限常量
const PERMISSIONS = {
  READ: 1 << 0, // 1   (001)
  WRITE: 1 << 1, // 2   (010)
  DELETE: 1 << 2, // 4   (100)
}

// 用户权限
let userPermissions = 0

// 授予权限
userPermissions |= PERMISSIONS.READ // 添加读权限
userPermissions |= PERMISSIONS.WRITE // 添加写权限

console.log(userPermissions) // 3 (011)

// 检查权限
function hasPermission(user, permission) {
  return !!(user & permission)
}

console.log(hasPermission(userPermissions, PERMISSIONS.READ)) // true
console.log(hasPermission(userPermissions, PERMISSIONS.DELETE)) // false

// 撤销权限
userPermissions &= ~PERMISSIONS.WRITE // 移除写权限
console.log(hasPermission(userPermissions, PERMISSIONS.WRITE)) // false
```

### 2. 状态管理

```javascript
// 组件状态标志
const COMPONENT_FLAGS = {
  MOUNTED: 1 << 0, // 1
  UPDATED: 1 << 1, // 2
  DESTROYED: 1 << 2, // 4
  LOADING: 1 << 3, // 8
  ERROR: 1 << 4, // 16
}

class Component {
  constructor() {
    this.flags = 0
  }

  mount() {
    this.flags |= COMPONENT_FLAGS.MOUNTED
  }

  update() {
    this.flags |= COMPONENT_FLAGS.UPDATED
  }

  setLoading(loading) {
    if (loading) {
      this.flags |= COMPONENT_FLAGS.LOADING
    } else {
      this.flags &= ~COMPONENT_FLAGS.LOADING
    }
  }

  isMounted() {
    return !!(this.flags & COMPONENT_FLAGS.MOUNTED)
  }

  isLoading() {
    return !!(this.flags & COMPONENT_FLAGS.LOADING)
  }

  getState() {
    return {
      mounted: this.isMounted(),
      updated: !!(this.flags & COMPONENT_FLAGS.UPDATED),
      destroyed: !!(this.flags & COMPONENT_FLAGS.DESTROYED),
      loading: this.isLoading(),
      error: !!(this.flags & COMPONENT_FLAGS.ERROR),
    }
  }
}

// 使用示例
const comp = new Component()
comp.mount()
comp.setLoading(true)
console.log(comp.getState())
// { mounted: true, updated: false, destroyed: false, loading: true, error: false }
```

### 3. 性能优化技巧

```javascript
// 1. 快速判断奇偶数
function isOdd(n) {
  return !!(n & 1) // 检查最低位
}

console.log(isOdd(5)) // true
console.log(isOdd(4)) // false

// 2. 快速乘除2的幂次
function multiplyBy4(n) {
  return n << 2 // 相当于 n * 4
}

function divideBy8(n) {
  return n >> 3 // 相当于 Math.floor(n / 8)
}

console.log(multiplyBy4(5)) // 20
console.log(divideBy8(40)) // 5

// 3. 交换两个变量 (不推荐，仅作演示)
let a = 5,
  b = 3
a ^= b
b ^= a
a ^= b
console.log(a, b) // 3 5

// 4. 清除最低位的1
function clearLowestBit(n) {
  return n & (n - 1)
}

console.log(clearLowestBit(12)) // 12: 1100 -> 1000 = 8

// 5. 获取最低位的1
function getLowestBit(n) {
  return n & -n
}

console.log(getLowestBit(12)) // 12: 1100 -> 0100 = 4
```

---

## Vue 3 中的位运算应用

### EffectFlags 分析

```javascript
// Vue 3 响应式系统中的标志
export enum EffectFlags {
  ACTIVE = 1 << 0,        // 1   - 副作用是否活跃
  RUNNING = 1 << 1,       // 2   - 是否正在执行
  TRACKING = 1 << 2,      // 4   - 是否追踪依赖
  NOTIFIED = 1 << 3,      // 8   - 是否已通知
  DIRTY = 1 << 4,         // 16  - 是否需要重新计算
  ALLOW_RECURSE = 1 << 5, // 32  - 是否允许递归
  PAUSED = 1 << 6,        // 64  - 是否暂停
  EVALUATED = 1 << 7,     // 128 - 是否已求值
}

// 使用示例
class ReactiveEffect {
  constructor() {
    // 初始状态：活跃且追踪依赖
    this.flags = EffectFlags.ACTIVE | EffectFlags.TRACKING
  }

  run() {
    // 检查是否活跃
    if (!(this.flags & EffectFlags.ACTIVE)) {
      return this.fn()
    }

    // 设置运行状态
    this.flags |= EffectFlags.RUNNING

    try {
      return this.fn()
    } finally {
      // 清除运行状态
      this.flags &= ~EffectFlags.RUNNING
    }
  }

  stop() {
    // 清除活跃状态
    this.flags &= ~EffectFlags.ACTIVE
  }

  pause() {
    // 设置暂停状态
    this.flags |= EffectFlags.PAUSED
  }

  resume() {
    // 清除暂停状态
    this.flags &= ~EffectFlags.PAUSED
  }
}
```

### PatchFlags 示例

```javascript
// Vue 3 虚拟DOM更新标志
export enum PatchFlags {
  TEXT = 1,           // 1 << 0 - 文本内容动态
  CLASS = 1 << 1,     // 2      - class 动态
  STYLE = 1 << 2,     // 4      - style 动态
  PROPS = 1 << 3,     // 8      - 属性动态
  FULL_PROPS = 1 << 4,// 16     - 具有动态key的props
  HYDRATE_EVENTS = 1 << 5, // 32 - 需要事件监听器
  STABLE_FRAGMENT = 1 << 6, // 64 - 稳定的fragment
  KEYED_FRAGMENT = 1 << 7,  // 128 - 带key的fragment
}

// 组合使用
const patchFlag = PatchFlags.TEXT | PatchFlags.CLASS  // 3 (011)

// 检查是否需要更新文本
if (patchFlag & PatchFlags.TEXT) {
  updateText(vnode)
}

// 检查是否需要更新class
if (patchFlag & PatchFlags.CLASS) {
  updateClass(vnode)
}
```

---

## 常见问题和陷阱

### 1. 有符号数问题

```javascript
// JavaScript 中的数字是 32 位有符号整数
console.log(~0) // -1 (不是 4294967295)
console.log(1 << 31) // -2147483648 (溢出变成负数)

// 解决方案：使用无符号右移
console.log((1 << 31) >>> 0) // 2147483648
```

### 2. 精度问题

```javascript
// JavaScript 数字精度限制
console.log(1 << 53) // 可能不准确

// 安全的位操作范围：-2^31 到 2^31-1
const MAX_SAFE_BIT = 30
console.log(1 << MAX_SAFE_BIT) // 1073741824 (安全)
```

### 3. 可读性问题

```javascript
// 不好的写法：直接使用数字
const flags = 5 // 什么意思？

// 好的写法：使用常量
const flags = READ_PERMISSION | WRITE_PERMISSION

// 更好的写法：添加注释
const flags =
  READ_PERMISSION | // 允许读取
  WRITE_PERMISSION // 允许写入
```

### 4. 调试技巧

```javascript
// 位运算调试工具函数
function debugBits(value, length = 8) {
  return {
    decimal: value,
    binary: value.toString(2).padStart(length, '0'),
    hex: '0x' + value.toString(16).toUpperCase(),
  }
}

console.log(debugBits(5))
// { decimal: 5, binary: "00000101", hex: "0x5" }

// 检查多个标志的工具函数
function checkFlags(value, flagsObject) {
  const result = {}
  for (const [name, flag] of Object.entries(flagsObject)) {
    result[name] = !!(value & flag)
  }
  return result
}

const FLAGS = { READ: 1, WRITE: 2, DELETE: 4 }
console.log(checkFlags(3, FLAGS))
// { READ: true, WRITE: true, DELETE: false }
```

---

## 实践练习

### 练习1：实现简单的权限系统

```javascript
// 需求：实现一个博客系统的权限管理
// 权限包括：查看、评论、发布、编辑、删除、管理

const BLOG_PERMISSIONS = {
  VIEW: 1 << 0, // 1   - 查看文章
  COMMENT: 1 << 1, // 2   - 发表评论
  POST: 1 << 2, // 4   - 发布文章
  EDIT: 1 << 3, // 8   - 编辑文章
  DELETE: 1 << 4, // 16  - 删除文章
  ADMIN: 1 << 5, // 32  - 管理员权限
}

// 预定义角色
const ROLES = {
  GUEST: BLOG_PERMISSIONS.VIEW,
  USER: BLOG_PERMISSIONS.VIEW | BLOG_PERMISSIONS.COMMENT,
  AUTHOR:
    BLOG_PERMISSIONS.VIEW |
    BLOG_PERMISSIONS.COMMENT |
    BLOG_PERMISSIONS.POST |
    BLOG_PERMISSIONS.EDIT,
  MODERATOR:
    BLOG_PERMISSIONS.VIEW |
    BLOG_PERMISSIONS.COMMENT |
    BLOG_PERMISSIONS.POST |
    BLOG_PERMISSIONS.EDIT |
    BLOG_PERMISSIONS.DELETE,
  ADMIN: Object.values(BLOG_PERMISSIONS).reduce((a, b) => a | b, 0),
}

class User {
  constructor(name, role = ROLES.GUEST) {
    this.name = name
    this.permissions = role
  }

  hasPermission(permission) {
    return !!(this.permissions & permission)
  }

  grantPermission(permission) {
    this.permissions |= permission
  }

  revokePermission(permission) {
    this.permissions &= ~permission
  }

  getPermissionList() {
    const permissions = []
    for (const [name, flag] of Object.entries(BLOG_PERMISSIONS)) {
      if (this.hasPermission(flag)) {
        permissions.push(name)
      }
    }
    return permissions
  }
}

// 测试
const user = new User('Alice', ROLES.AUTHOR)
console.log(user.getPermissionList()) // ["VIEW", "COMMENT", "POST", "EDIT"]

user.grantPermission(BLOG_PERMISSIONS.DELETE)
console.log(user.hasPermission(BLOG_PERMISSIONS.DELETE)) // true

user.revokePermission(BLOG_PERMISSIONS.POST)
console.log(user.hasPermission(BLOG_PERMISSIONS.POST)) // false
```

### 练习2：实现特性开关系统

```javascript
// 需求：实现一个应用的特性开关系统
// 可以动态开启/关闭不同的功能特性

const FEATURES = {
  NEW_UI: 1 << 0, // 新UI界面
  DARK_MODE: 1 << 1, // 深色模式
  BETA_FEATURE: 1 << 2, // 测试功能
  ANALYTICS: 1 << 3, // 数据统计
  NOTIFICATIONS: 1 << 4, // 通知功能
  OFFLINE_MODE: 1 << 5, // 离线模式
  EXPERIMENTAL_API: 1 << 6, // 实验性API
}

class FeatureToggle {
  constructor() {
    // 默认开启的功能
    this.enabledFeatures =
      FEATURES.NEW_UI | FEATURES.ANALYTICS | FEATURES.NOTIFICATIONS
  }

  enable(feature) {
    this.enabledFeatures |= feature
  }

  disable(feature) {
    this.enabledFeatures &= ~feature
  }

  toggle(feature) {
    this.enabledFeatures ^= feature
  }

  isEnabled(feature) {
    return !!(this.enabledFeatures & feature)
  }

  enableMultiple(features) {
    this.enabledFeatures |= features
  }

  disableAll() {
    this.enabledFeatures = 0
  }

  enableAll() {
    this.enabledFeatures = Object.values(FEATURES).reduce((a, b) => a | b, 0)
  }

  getEnabledFeatures() {
    const enabled = []
    for (const [name, flag] of Object.entries(FEATURES)) {
      if (this.isEnabled(flag)) {
        enabled.push(name)
      }
    }
    return enabled
  }

  // 导出配置
  exportConfig() {
    return this.enabledFeatures
  }

  // 导入配置
  importConfig(config) {
    this.enabledFeatures = config
  }
}

// 使用示例
const features = new FeatureToggle()

console.log(features.getEnabledFeatures())
// ["NEW_UI", "ANALYTICS", "NOTIFICATIONS"]

// 开启深色模式和离线模式
features.enableMultiple(FEATURES.DARK_MODE | FEATURES.OFFLINE_MODE)

// 切换测试功能
features.toggle(FEATURES.BETA_FEATURE)

console.log(features.isEnabled(FEATURES.DARK_MODE)) // true
console.log(features.isEnabled(FEATURES.BETA_FEATURE)) // true

// 保存配置
const config = features.exportConfig()
console.log(`配置值: ${config}`)

// 恢复配置
const newFeatures = new FeatureToggle()
newFeatures.importConfig(config)
console.log(newFeatures.getEnabledFeatures())
```

---

## 总结

位运算是一种强大而高效的编程技术，主要优势包括：

1. **性能优势**：执行速度快，内存占用少
2. **功能强大**：可以实现复杂的状态管理和权限控制
3. **代码简洁**：用少量代码实现复杂逻辑
4. **广泛应用**：在系统编程、算法、框架源码中大量使用

### 学习要点

1. **掌握基础**：理解二进制和各种位运算符
2. **实践应用**：通过实际项目加深理解
3. **注意陷阱**：了解JavaScript中位运算的限制
4. **工具辅助**：使用调试工具帮助理解

### 进阶学习

1. 研究开源框架（Vue、React）中的位运算应用
2. 学习算法中的位运算技巧
3. 了解底层原理和性能优化
4. 实践更复杂的应用场景

位运算虽然看起来抽象，但通过充分的练习和实际应用，你会发现它是编程中的一个强大工具。
